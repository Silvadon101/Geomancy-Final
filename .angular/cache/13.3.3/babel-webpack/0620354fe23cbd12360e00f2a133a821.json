{"ast":null,"code":"export const name = \"Line Group Collision Manager\";\nconst X = 'x';\nconst Y = 'y';\n/**\r\n * Creates a structure representing the data of a single coordinate\r\n * @param x - The horizontal coordinate\r\n * @param y - The vertical coordinate\r\n */\n\nexport class Point {\n  constructor(x, y) {\n    this._x = x;\n    this._y = y;\n  }\n\n  get x() {\n    return this._x;\n  }\n\n  get y() {\n    return this._y;\n  }\n\n}\n/**\r\n * @description Creates a structure generating the data of a single line between two points\r\n * @param point1 The starting point\r\n * @param point2 The ending point\r\n * @param etc. Singular coordinate entry mode\r\n */\n\nexport class Line {\n  constructor(point1, point2, x, y, x2, y2) {\n    if (point1 == point2) {\n      throw new Error(\"A line must have a length.\");\n    }\n\n    this._x = x !== null && x !== void 0 ? x : point1.x;\n    this._y = y !== null && y !== void 0 ? y : point1.y;\n    this._x2 = x2 !== null && x2 !== void 0 ? x2 : point2.x;\n    this._y2 = y2 !== null && y2 !== void 0 ? y2 : point2.y;\n    this._m = (this._y2 - this._y) / (this._x2 - this._x);\n    this._m = this._m;\n    this._c = this._y - this._m * this._x;\n    this._c = this._c;\n    this.lowBoundX = this._x < this._x2 ? this._x : this._x2;\n    this.upperBoundX = this._x > this._x2 ? this._x : this._x2;\n    this.lowBoundY = this._y < this._y2 ? this._y : this._y2;\n    this.upperBoundY = this._y > this._y2 ? this._y : this._y2;\n    this._length = Math.pow(Math.pow(Math.abs(this._x - this._x2), 2) + Math.pow(Math.abs(this._y - this._y2), 2), 0.5);\n  }\n\n  get x() {\n    return this._x;\n  }\n\n  get y() {\n    return this._y;\n  }\n\n  get x2() {\n    return this._x2;\n  }\n\n  get y2() {\n    return this._y2;\n  }\n\n  get m() {\n    return this._m;\n  }\n\n  get c() {\n    return this._c;\n  }\n\n  get XBounds() {\n    return new Point(this.lowBoundX, this.upperBoundX);\n  }\n\n  get YBounds() {\n    return new Point(this.lowBoundY, this.upperBoundY);\n  }\n\n  get length() {\n    return this._length;\n  }\n  /**\r\n   * @description Returns true if a certain point lies upon the line\r\n   * @param point The aforementioned point\r\n   * @returns Wether or not the point is on the line\r\n   */\n\n\n  pointOnLine(point) {\n    if (Math.round(point.x * 1000) == Math.round(this._x * 1000) && Math.round(point.y * 1000) == Math.round(this._y * 1000) || Math.round(point.x * 1000) == Math.round(this._x2 * 1000) && Math.round(point.y * 1000) == Math.round(this._y2 * 1000)) {\n      return true;\n    } else if (Math.round(this.xgiveny(point.y) * 1000) == Math.round(point.x * 1000)) {\n      let inX = Math.round(point.x * 1000) >= Math.round(this.lowBoundX * 1000) && Math.round(point.x * 1000) <= Math.round(this.upperBoundX * 1000);\n      let inY = Math.round(point.y * 1000) >= Math.round(this.lowBoundY * 1000) && Math.round(point.y * 1000) <= Math.round(this.upperBoundY * 1000);\n      return inX && inY;\n    } else {\n      return false;\n    }\n  }\n  /**\r\n   * @description Provides an x value given a corresponding y value\r\n   * @param y The y coordinate\r\n   * @returns The x coordinate\r\n   */\n\n\n  xgiveny(y) {\n    return !Number.isFinite(this.m) ? this._x : (y - this._c) / this.m;\n  }\n  /**\r\n   * @description Provides a y value given an x value, but if the line is vertical a boolean is returned stating wether or not that x value is that of the line\r\n   * @param x The x coordinate\r\n   * @returns The y coordinate\r\n   */\n\n\n  ygivenx(x) {\n    let aligned = Math.round(x * 1000) == Math.round(this._x * 1000);\n    return !Number.isFinite(this.m) ? aligned : this._m * x + this._c;\n  }\n  /**\r\n   * @description Provides a point along the line with a corresponding length\r\n   * @param length The length along the line group to travel\r\n   * @returns The point\r\n   */\n\n\n  pointFromLength(length) {\n    let newLine = new Line2(new Point(this._x, this._y), Math.atan(this._m), length, new Point(this._x2, this._y2));\n    return new Point(newLine.x2, newLine.y2);\n  }\n\n}\n/**\r\n * @description Creates a structure generating the data of a single line between two points\r\n */\n\nexport class Line2 extends Line {\n  constructor(point, rads, length, directive) {\n    let opp = Math.sin(rads) * length;\n    let adj = Math.cos(rads) * length;\n    let left = point.x > directive.x;\n    let right = !left;\n    let equal = point.x == directive.x;\n    let up = point.y > directive.y;\n    let down = !up;\n\n    if (left) {\n      super(point, new Point(point.x - adj, point.y - opp));\n    } else if (right) {\n      super(point, new Point(point.x + adj, point.y + opp));\n    } else if (equal) {\n      if (up) {\n        super(point, new Point(point.x + adj, point.y - opp));\n      } else if (down) {\n        super(point, new Point(point.x - adj, point.y + opp));\n      }\n    }\n  }\n\n}\n/**\r\n * @description Creates a structure generating the data of a circle\r\n * @param point The center point\r\n * @param r The length of the radius\r\n */\n\nexport class Circle extends Point {\n  constructor(point, r) {\n    r = r == 0 ? 1 : r;\n    super(point.x, point.y);\n    this._r = r;\n  }\n\n  get r() {\n    return this._r;\n  }\n  /**\r\n   * @description Provides a point indicated by the radians of the angle from the centre of the circle\r\n   * @param rads Radian value\r\n   * @returns The point\r\n   */\n\n\n  pointFromRadians(rads) {\n    rads %= 2 * Math.PI;\n    let point = new Point(this._r * Math.cos(rads) + this.x, this._r * Math.sin(rads) + this._y);\n    return point;\n  }\n  /**\r\n   * @description Provides the radians of the angle from the centre of the circle that would intersect a certain points\r\n   * @param point The aforementioned point\r\n   * @returns The point\r\n   */\n\n\n  radiansFromPoint(point) {\n    let rads = Math.atan2(point.y - this.y, point.x - this.x);\n    return rads;\n  }\n  /**\r\n   * @description Provides the line from the centre of the circle indicated by the radians provided\r\n   * @param rads The radians\r\n   * @returns The line\r\n   */\n\n\n  lineFromRadians(rads) {\n    rads %= 2 * Math.PI;\n    let point = new Point(this._r * Math.cos(rads) + this.x, this._r * Math.sin(rads) + this._y);\n    return new Line(point, new Point(this._x, this._y));\n  }\n\n}\nexport class LineGroup {\n  constructor(...points) {\n    this._lineArray = [];\n    this._length = 0;\n    this.topBound = Number.POSITIVE_INFINITY;\n    this.leftBound = Number.POSITIVE_INFINITY;\n    this.bottomBound = Number.NEGATIVE_INFINITY;\n    this.rightBound = Number.NEGATIVE_INFINITY;\n    points.forEach((value, index) => {\n      let buffer;\n\n      if (index != points.length - 1) {\n        buffer = new Line(value, points[index + 1]);\n\n        this._lineArray.push(buffer);\n\n        this._length += buffer.length;\n      }\n\n      if (this.topBound >= value.y) this.topBound = value.y;\n      if (this.leftBound >= value.x) this.leftBound = value.x;\n      if (this.bottomBound <= value.y) this.topBound = value.y;\n      if (this.rightBound <= value.x) this.leftBound = value.x;\n    });\n  }\n\n  get lineArray() {\n    return this._lineArray;\n  }\n\n  get length() {\n    return this._length;\n  }\n  /**\r\n   * @description Provides the first point that would be intersected in the line group provided a line\r\n   * @param line The aforementioned line\r\n   * @returns The point\r\n   */\n\n\n  pointFromLine(line) {\n    for (let i = 0; i < this._lineArray.length; i++) {\n      let element = this._lineArray[i];\n\n      if (!Number.isFinite(line.m) && !Number.isFinite(element.m)) {\n        if (element.x >= line.XBounds.x && element.x <= line.XBounds.y) {\n          if (element.y >= line.YBounds.x && element.y <= line.YBounds.y) {\n            return new Point(element.x, element.y);\n          }\n        }\n\n        if (element.x2 >= line.XBounds.x && element.x2 <= line.XBounds.y) {\n          if (element.y2 >= line.YBounds.x && element.y2 <= line.YBounds.y) {\n            return new Point(element.x2, element.y2);\n          }\n        }\n\n        if (line.x2 >= element.XBounds.x && line.x2 <= element.XBounds.y) {\n          if (line.y2 >= element.YBounds.x && line.y2 <= element.YBounds.y) {\n            return new Point(line.x2, line.y2);\n          }\n        }\n\n        if (line.x >= element.XBounds.x && line.x <= element.XBounds.y) {\n          if (line.y >= element.YBounds.x && line.y <= element.YBounds.y) {\n            return new Point(line.x, line.y);\n          }\n        }\n      }\n\n      let interx;\n      let intery;\n\n      if (!Number.isFinite(line.m)) {\n        interx = line.x;\n        intery = element.ygivenx(line.x);\n      } else if (!Number.isFinite(element.m)) {\n        interx = element.x;\n        intery = line.ygivenx(element.x);\n      } else {\n        interx = (line.c - element.c) / (element.m - line.m);\n        intery = (element.m * line.c - element.c * line.m) / (element.m - line.m);\n      }\n\n      let intersect = new Point(interx, intery);\n\n      if (element.pointOnLine(intersect)) {\n        if (line.pointOnLine(intersect)) {\n          return new Point(interx, intery);\n        }\n      }\n    }\n\n    return null;\n  }\n  /**\r\n   * @description Provides the point indicated by a length along the line group\r\n   * @param length The length\r\n   * @returns The point\r\n   */\n\n\n  pointFromLength(length) {\n    for (let i = 0; i < this.lineArray.length; i++) {\n      length -= this.lineArray[i].length;\n\n      if (length <= 0) {\n        length += this.lineArray[i].length;\n        return this.lineArray[i].pointFromLength(length);\n      }\n    }\n\n    return null;\n  }\n\n}\nexport class PolygonLineGroup extends LineGroup {\n  constructor(point, r, sides, startr) {\n    r = r == 0 ? 1 : r;\n    sides = sides !== null && sides !== void 0 ? sides : 3;\n    sides = sides < 3 ? 3 : sides;\n    let PolyBaseCircle = new Circle(point, r);\n    let unit = 2 * Math.PI / sides;\n    let points = [];\n\n    for (let i = 0; i < sides; i++) {\n      let a = PolyBaseCircle.pointFromRadians((startr + unit * i) % (2 * Math.PI));\n      points.push(a);\n    }\n\n    points.push(PolyBaseCircle.pointFromRadians(startr % (2 * Math.PI)));\n    super(...points);\n    this._PolyBaseCircle = PolyBaseCircle;\n    this._initAngle = startr;\n    this._faces = sides;\n  }\n\n  get initAngle() {\n    return this._initAngle;\n  }\n\n  get faces() {\n    return this._faces;\n  }\n\n  get PolyBaseCircle() {\n    return this._PolyBaseCircle;\n  }\n  /**\r\n   * @description Provides a point indicated by the radians of the angle from the centre of the circle\r\n   * @param r Radian value\r\n   * @returns The point\r\n   */\n\n\n  pointFromRadians(r) {\n    let keyLine = this._PolyBaseCircle.lineFromRadians(r);\n\n    return this.pointFromLine(keyLine);\n  }\n  /**\r\n   * @description Provides the radians of the angle from the centre of the circle that would intersect a certain points\r\n   * @param point The aforementioned point\r\n   * @returns The point\r\n   */\n\n\n  radiansFromPoint(point) {\n    return this._PolyBaseCircle.radiansFromPoint(point);\n  }\n\n}\n\nfunction between(target, bound1, bound2) {\n  let lowbound = bound1 < bound2 ? bound1 : bound2;\n  let highbound = bound1 > bound2 ? bound1 : bound2;\n  return target > lowbound && target < highbound;\n}\n\nfunction inc_between(target, bound1, bound2) {\n  let lowbound = bound1 < bound2 ? bound1 : bound2;\n  let highbound = bound1 > bound2 ? bound1 : bound2;\n  return target >= lowbound && target <= highbound;\n}","map":null,"metadata":{},"sourceType":"module"}